\documentclass[a4paper,10pt]{article}
\usepackage[margin=0.5in]{geometry}
\usepackage{amsthm}
\usepackage[latin1]{inputenc}
%\usepackage[utf8]{inputenc}
%\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{float}
%\usepackage{amssymb}
\usepackage{fancyvrb}
\usepackage{indentfirst}
\usepackage{array}
\usepackage{graphicx}
\usepackage[round]{natbib}
\usepackage{array}
\theoremstyle{plain}
\usepackage{color}
\usepackage[boxed,commentsnumbered]{algorithm2e}
\newtheorem{theo}{Theorem}
\newtheorem{defn}{Definition}


\newcommand{\argmin}{\arg\!\min}
\newcommand{\argmax}{\arg\!\max}

\begin{document}
\author{Ieltzu Irazu, Mikel De Velasco Y María Inés Fernandez}
\pagenumbering{arabic}
\title{Práctica 8}

\author{\thanks{}}
\date{\today}
\maketitle

\section{Introducción:}
\subsection{Exposición de la práctica:}
En la práctica presentada se nos pide implementar los algoritmos de optimización denominados búsqueda local(para una sola solución) y algoritmos genéticos(varias soluciones) para el conjunto de datos dantzig42. Para ello hemos desarrollado nuestro código en el lenguaje de programación Java y después hemos creado nuestro ejecutador .jar. Además hemos desarrollado este documento para plasmar las partes más importantes de la práctica.

\subsection{Objetivos:}
Los objetivos son claros; conseguir un algoritmo eficiente y efectivo para optimizar una solción o un conjuntos de soluciones de un conjunto de datos. El problema planteado tiene nombre propio TSP. El código que hemos desarrollado no es dependiente a un solo conjunto de datos,ya que es posible utilizarlo en más de un conjunto de datos(menos la lectura).

Como hemos recibido el archivo dantzig42 para desarrollar la práctica, vamos a analizar el archivo para ver su contenido. En el archivo de datos podemos encontrar un conjunto de valores numéricos separados por ceros. Estos ceros indican un salto de linea. Si procesamos estos datos, conseguimos la mitad una matriz de una dimensión de 49x49. Como tenemos 49 ciudades, el punto en común de los pares de ciudades nos indica cual es el peso de una ciudad a otra.

Para optimizar nuestras ciudades vamos a aplicar distintos criterios en el proceso. Empezaremos utilizando el criterio Best First y luego utilizaremos el Greedy, para la búsqueda local. Una vez conseguidos estos procesos, haremos el calculo de el algoritmo genético.  

\section{Explicación y Pseudocódigo del algoritmo:}
QUITAR QUITAR
3. Experimentación. (Las distintas configuraciones de parámetros que se han utilizado, y los resultados obtenidos. Cuantas repeticiones...)

P.D. Siguiendo a la buena costumbre de las practicas. Quiero que me entregueis un JAR con el codigo ( o dos JARs, uno por cada algoritmo). Cuando se ejecute el JAR, este repetira la optimizacion 10 veces, y devolvera la lista de resultados obtenidos, asi como la mejor solucion y el fitness medio de todas las soluciones obtenidas.
QUITAR QUITAR
En el algoritmo de búsqueda local se recibe una solución la cual se pretende optimizar. La solución recibida se utilizará para calcular una combinatoria de todos los swaps posibles entre dos de las ciudades del camino. Una vez calculados estos nuevos caminos, se buscará el mejor camino de todos, o el primero mejor que encontremos(Greedy,BestFirst) comparándolos con nuestra solución de entrada. Si encontramos un camino mejor que el de nuestra entrada, el camino, pasará a ser la nueva entrada, y así, seguiremos hasta que ningún vecino supere a nuestra solución de entrada.

\begin{algorithm}[H] 
\caption{Búsqueda Local} 
\SetKwInOut{Input}{entrada} 
\SetKwInOut{Output}{salida}
\Input{Listaciudades} 
\Output{ListaCiudadesOptima} 
\While{$Valor(ListaCiudades) >= Valor(ListaCiudadesOptima)$ \& $! TiempoComputacionalAcabado$ \& $! Numero de iteraciones máximo$}{
	 $Combinatoria = CrearCombinatoriaDeSwaps()$\\
	 $ListaCiudadesOptima = BusquedaMejorLista(Combinatoria)$\\
	 \eIf{$ListaCiudadesOptima <= ListaCiudades$}{
	 	\Return $ListaCiudades$
	 }{
	 	$ListaCiudades=ListaCiudadesOptima$\\
	 }
}
\Return $ListaCiudades$
\end{algorithm} 
\\
	En el algoritmo genético se recibe una población de soluciones para optimizar. 	Estas soluciones se ordenarán en base a su valor de salida(adaptación). Una vez obtenida la lista ordenada, se procederá a recoger la mitad de las muestras en sentido de valor de salida descendente. De estas muestras conseguidas, se harán cruces. Estos cruces crearán el mismo número de hijos que padres hemos cogido.\\

	Para hacer los cruces hemos utilizado el algoritmo Order 1 CrossOver. En este algoritmo un segmento de uno de los padres pasará en orden al hijo. La información restante ocupará los trozos de información vacíos siempre que la información no este ya incluida en el primer segmento. He aquí el algoritmo.\\\\

\begin{algorithm}[H] 
\caption{Order 1 CrossOver} 
\SetKwInOut{Input}{entrada} 
\SetKwInOut{Output}{salida}
\Input{ListaCiudades1(P1),ListaCiudades2(P2)} 
\Output{ListaCiudadesHijo1,ListaCiudadesHijo2} 
\While{$Numerohijos<2$}{
	 Elegir segmento de azar y copiarlo de P1 en hijo\\
	\For{$Para cada elemento fuera del segmento, empezando desde el final del segmento$}{ 
		\If {$el elemento seleccionado de P2 no está en el segmento seleccionado de P1$}{
			colocarlo en orden después del segmento en P3(si lista está llena se empezará desde el principio hasta el principio del segmento)\\
		}\\
	}
}
\Return $ListaCiudadeshijo1,ListaCiudadesHijo2$
\end{algorithm} 
	 
	 Los hijos sufrirán mutaciones en el 30 por ciento de los casos(criterio establecido por nosotros) y se hará un nuevo conjunto de datos entre los padres y los hijos mutados y no mutados. De esta forma se obtendrá una población del mismo número de la que teníamos de entrada.\\

El algoritmo puede converger en estos tres casos:
\begin{itemize}
	\item Tiempo computacional.
	\item Numero de iteraciones.
	\item Población de rasgos muy similares.
\end{itemize}
	

\begin{algorithm}[H] 
\caption{Algoritmo Genético} 
\SetKwInOut{Input}{entrada} 
\SetKwInOut{Output}{salida}
\Input{PoblacionListaCiudades} 
\Output{PoblacionListaCiudadesMejoradas} 
\While{$! TiempoComputacionalAcabado$ \& $! Numero de iteraciones máximo$}{
	 $PoblacionOrdenada = OrdenarPoblacionListaCiudades()$\\
	 $Cruces = CrearCruces(PoblacionOrdenada/2)$\\
	 $mutaciones = CrearMutaciones(Cruces)$ 	\\	 $PoblaciónListaCiudadesMejoradas=ReemplazarMutacionesPorMuestrasDeBajoNivel(PoblacionOrdenada,Mutaciones)$\\
}
\Return &$PoblaciónListaCiudadesMejoradas$
\end{algorithm} 

\section{Experimentación y Resultados:}
Hemos ejecutado el programa y nos han salido estos resultados:

\begin{figure}[H]
\caption{gráfico 1} 
\centering
\includegraphics[width=0.6\textwidth]{./grafica1.png}
\end{figure}

Aquí escribimos conclusiones\\

\section{Conclusiones:}
Implementar los algoritmos nos ha llevado a sacar varias conclusiones. El algoritmo de búsqueda local usando Greedy o BestFirst como criterio es mucho más fácil de implementar que el algoritmo genético. Planificar los cruces ha sido la parte mas costosa del problema en los algoritmos genéticos. Una vez que se sabe como funciona bien el algoritmo es sencillo implementarlo.\\ 
El algoritmo genético ofrece mejores resultados que el de búsqueda local. Según el numero de población va aumentando los resultados de los algoritmos genéticos aumenta, al igual que su costo computacional. 
La búsqueda local ofrece un resultado bueno sin mucho costo computacional. Si les diéramos el mismo tiempo de ejecución a los dos algoritmos sin duda el algoritmo de búsqueda local daría mejores resultados.
Respondiendo a la pregunta de que algoritmo funciona mejor con la solución base, la respuesta es el algoritmo genético aunque no ofrece unos resultados tan diferentes como esperábamos.\\
En nuestra opinión no es un algoritmo que sea mejor, simplemente que con un mayor número de iteraciones y mayor tiempo computacional ofrece mejores resultados que la búsqueda local, ya que, este algoritmo no mejora tanto aunque el tiempo computacional aumente considerablemente.\\  
	
\section{Valoración Subjetiva:}
\textbf{Ieltzu}: Ha sido una práctica en la que no hemos invertido mucho tiempo. Los tres teníamos que haber estudiado los dos algoritmos, por lo tanto, no ha sido muy complicado implementarlo. Práctica interesante, pero en la época del año que nos ha pillado, para mi, sobraba.\\
\textbf{Mikel}: 


\textbf{Maria}:



\section*{Bibliografia}
\begin{itemize}
	\item http://www.herrera.unt.edu.ar/gapia/Curso_AG/Curso_AG_08_Clase_5.pdf
	\item \\
	\item http://www.sc.ehu.es/ccwbayes/docencia/mmcc/docs/t2geneticos.pdf
\end{itemize}

\end{document}

